#!/usr/bin/env bash
set -euo pipefail

###############################################################################
# SpecKit repo-pinned entrypoint
#
# Responsibilities:
# - Canonical command: ./specify
# - Ensure Python + venv exist
# - Ensure SpecKit is installed at pinned version
# - Prevent global / PATH-based execution
# - Work for humans, CI, editors, and AI agents
###############################################################################

ROOT="$(cd "$(dirname "$0")" && pwd)"
VENV="$ROOT/.venv"
SPECIFY="$VENV/bin/specify"
PIP="$VENV/bin/pip"
PYTHON="${PYTHON:-python3}"

# ---------------------------------------------------------------------------
# Configuration (PIN HERE)
# ---------------------------------------------------------------------------

# Wrapper version (Semantic Versioning)
SPECIFYRUN_VERSION="0.6.0"

# Pin SpecKit source and ref
SPECKIT_GIT="https://github.com/github/spec-kit.git"
SPECKIT_REF="v0.0.90"

# Marker to avoid re-install loops
STAMP="$VENV/.speckit-installed-$SPECKIT_REF"

# Marker for gitignore block identification
GITIGNORE_MARKER="# specify-run"

# Required patterns for security hardenings verification
REQUIRED_GITIGNORE_PATTERNS=(
  ".venv/"
  "!.specify/"
  "!.specify/scripts/**"
  "!.specify/templates/**"
  "!.specify/memory/**"
  ".specify/cache/"
  ".specify/tmp/"
  ".specify/logs/"
  ".specify/.runtime/"
)

# ---------------------------------------------------------------------------
# Exit codes (BSD sysexits)
# ---------------------------------------------------------------------------

EX_TEMPFAIL=75
EX_CONFIG=78

# ---------------------------------------------------------------------------
# Version command (early exit, no side effects)
# ---------------------------------------------------------------------------

print_version_banner() {
  local title_name="specify-run"
  local title_ver="$SPECIFYRUN_VERSION"
  local subtitle="Deterministic SpecKit Execution with Safety"
  local term_width="${COLUMNS:-$(tput cols 2>/dev/null </dev/tty 2>/dev/null || echo 80)}"
  local min_width=$((${#subtitle} + 4))

  if [[ $term_width -lt $min_width ]]; then
    echo ">>> $title_name $title_ver"
    echo "    $subtitle"
    return
  fi

  local width=$((term_width - 2))
  local title="$title_name $title_ver"
  local title_pad=$(( (width - ${#title}) / 2 ))
  local subtitle_pad=$(( (width - ${#subtitle}) / 2 ))
  local bold=$'\033[1m'
  local reset=$'\033[0m'
  printf '╭%s╮\n' "$(printf '─%.0s' $(seq 1 $width))"
  printf '│%*s│\n' "$width" ""
  printf '│%*s%s%s%s %s%*s│\n' "$title_pad" "" "$bold" "$title_name" "$reset" "$title_ver" "$((width - title_pad - ${#title}))" ""
  printf '│%*s│\n' "$width" ""
  printf '│%*s%s%*s│\n' "$subtitle_pad" "" "$subtitle" "$((width - subtitle_pad - ${#subtitle}))" ""
  printf '│%*s│\n' "$width" ""
  printf '╰%s╯\n' "$(printf '─%.0s' $(seq 1 $width))"
}

if [[ "${1:-}" == "version" ]]; then
  print_version_banner
  if [[ -x "$SPECIFY" ]]; then
    echo ""
    exec "$SPECIFY" "$@"
  fi
  exit 0
fi

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

die() {
  echo "ERROR: $*" >&2
  exit 1
}

info() {
  echo "[specify-run] $*"
}

prompt_user() {
  local key="$1"
  local message="$2"
  local response
  local answer
  echo "[specify-run] $message"
  if answer=$(get_answer "$key"); then
    case "$answer" in
      [Yy]*) return 0 ;;
      *) exit 130 ;;
    esac
  elif is_interactive; then
    read -r -p "Proceed? [Y/n]: " response
    case "${response:-y}" in
      [Yy]*) return 0 ;;
      *) exit 130 ;;
    esac
  elif is_agentic; then
    echo "Append \`$key=y\` to SPECIFYRUN_ANSWERS environment variable to proceed."
    exit "$EX_TEMPFAIL"
  else
    exit "$EX_CONFIG"
  fi
}

get_answer() {
  local key="$1"
  local answers="${SPECIFYRUN_ANSWERS:-}"
  [[ -z "$answers" ]] && return 1
  local IFS=','
  for pair in $answers; do
    local k="${pair%%=*}"
    local v="${pair#*=}"
    if [[ "$k" == "$key" ]]; then
      echo "$v"
      return 0
    fi
  done
  return 1
}

is_interactive() {
  [[ -t 0 ]]
}

is_agentic() {
  [[ "${SPECIFYRUN_BY_AGENT:-0}" == "1" ]]
}

is_git_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

is_file_dirty() {
  local file="$1"
  [[ -n "$(git diff --name-only -- "$file" 2>/dev/null)" ]] ||
  [[ -n "$(git diff --cached --name-only -- "$file" 2>/dev/null)" ]]
}

is_fresh_provisioning() {
  [[ ! -d "$VENV" ]]
}

MISSING_PATTERNS=()

check_gitignore_hardenings() {
  is_git_repo || return 0
  local gitignore="$ROOT/.gitignore"
  MISSING_PATTERNS=()

  if [[ ! -f "$gitignore" ]]; then
    MISSING_PATTERNS=("${REQUIRED_GITIGNORE_PATTERNS[@]}")
    return 1
  fi

  if ! grep -q "$GITIGNORE_MARKER" "$gitignore"; then
    MISSING_PATTERNS=("${REQUIRED_GITIGNORE_PATTERNS[@]}")
    return 1
  fi

  for pattern in "${REQUIRED_GITIGNORE_PATTERNS[@]}"; do
    if ! grep -Fxq "$pattern" "$gitignore"; then
      MISSING_PATTERNS+=("$pattern")
    fi
  done

  [[ ${#MISSING_PATTERNS[@]} -eq 0 ]]
}

show_missing_hardenings() {
  echo "[specify-run] Security hardenings incomplete."
  echo "Missing .gitignore patterns:"
  for pattern in "${MISSING_PATTERNS[@]}"; do
    echo "  - $pattern"
  done
}

block_if_target_dirty() {
  local gitignore="$ROOT/.gitignore"
  if [[ -f "$gitignore" ]] && is_file_dirty "$gitignore"; then
    echo "[specify-run] Security hardenings incomplete, but .gitignore has uncommitted changes."
    echo "Commit or revert your .gitignore changes first, then re-run."
    exit "$EX_CONFIG"
  fi
}

apply_gitignore_hardenings() {
  local gitignore="$ROOT/.gitignore"

  if [[ ! -f "$gitignore" ]] || ! grep -q "$GITIGNORE_MARKER" "$gitignore"; then
    local block="
$GITIGNORE_MARKER
.venv/
!.specify/
!.specify/scripts/**
!.specify/templates/**
!.specify/memory/**

.specify/cache/
.specify/tmp/
.specify/logs/
.specify/.runtime/
"
    if ! echo "$block" >> "$gitignore" 2>/dev/null; then
      echo "WARNING: Could not write to .gitignore (read-only or permission denied)" >&2
      return 1
    fi
  else
    for pattern in "${MISSING_PATTERNS[@]}"; do
      echo "$pattern" >> "$gitignore"
    done
  fi

  info "Configured .gitignore"
}

stop_after_gitignore_fix() {
  echo "[specify-run] Security hardenings applied."
  echo "Please commit these changes, then re-run ./specify-run:"
  echo "  git add .gitignore && git commit -m \"fix: restore specify-run security hardenings\""
  exit "$EX_TEMPFAIL"
}

PROVISIONED_AGENTS=()

detect_provisioned_agents() {
  PROVISIONED_AGENTS=()
  if ls "$ROOT/.claude/commands/speckit."*.md >/dev/null 2>&1; then
    PROVISIONED_AGENTS+=("claude")
  fi
  if ls "$ROOT/.github/prompts/speckit."*.prompt.md >/dev/null 2>&1; then
    PROVISIONED_AGENTS+=("copilot")
  fi
  if ls "$ROOT/.gemini/speckit."*.md >/dev/null 2>&1; then
    PROVISIONED_AGENTS+=("gemini")
  fi
  if ls "$ROOT/.cursor/prompts/speckit."*.md >/dev/null 2>&1; then
    PROVISIONED_AGENTS+=("cursor-agent")
  fi
}

MEMORY_BACKUP=""

backup_memory() {
  MEMORY_BACKUP=""
  if [[ -d "$ROOT/.specify/memory" ]]; then
    MEMORY_BACKUP="$(mktemp -d)"
    cp -R "$ROOT/.specify/memory/." "$MEMORY_BACKUP/"
    info "Backed up .specify/memory/"
  fi
}

restore_memory() {
  if [[ -n "$MEMORY_BACKUP" ]]; then
    rm -rf "$ROOT/.specify/memory"
    mv "$MEMORY_BACKUP" "$ROOT/.specify/memory"
    MEMORY_BACKUP=""
    info "Preserved .specify/memory/ (project-specific files)"
  fi
}

# ---------------------------------------------------------------------------
# Sanity checks
# ---------------------------------------------------------------------------

command -v "$PYTHON" >/dev/null \
  || die "Python not found (set PYTHON=python3.x if needed)"

# ---------------------------------------------------------------------------
# Ensure virtualenv
# ---------------------------------------------------------------------------

FRESH_PROVISIONING=false
if [[ ! -d "$VENV" ]]; then
  FRESH_PROVISIONING=true
  prompt_user "bootstrap" "About to create .venv/ and install SpecKit $SPECKIT_REF"
  info "Creating virtualenv at .venv"
  "$PYTHON" -m venv "$VENV"
  is_git_repo && apply_gitignore_hardenings
fi

# ---------------------------------------------------------------------------
# Ensure SpecKit installed (pinned)
# ---------------------------------------------------------------------------

if [[ ! -f "$STAMP" ]]; then
  OLD_REF=""
  for f in "$VENV"/.speckit-installed-*; do
    [[ -f "$f" ]] && OLD_REF="${f##*-installed-}" && break
  done
  if [[ -n "$OLD_REF" ]]; then
    prompt_user "upgrade" "About to upgrade SpecKit from $OLD_REF to $SPECKIT_REF"
    rm -f "$VENV"/.speckit-installed-*

    info "Installing SpecKit CLI ($SPECKIT_REF)"
    "$PIP" install --upgrade \
      "git+$SPECKIT_GIT@$SPECKIT_REF"

    # Re-bootstrap project files (preserve memory, replace scripts/templates)
    detect_provisioned_agents
    if [[ ${#PROVISIONED_AGENTS[@]} -gt 0 ]]; then
      backup_memory
      for agent in "${PROVISIONED_AGENTS[@]}"; do
        info "Re-bootstrapping for $agent..."
        if ! "$SPECIFY" init --here --force --ai "$agent"; then
          restore_memory
          die "SpecKit upgrade failed during $agent re-bootstrap"
        fi
      done
      restore_memory
      info "Replaced .specify/scripts/ and .specify/templates/"
    else
      info "No SpecKit project files found - skipping re-bootstrap"
    fi

    touch "$STAMP"
    echo "[specify-run] SpecKit upgraded to $SPECKIT_REF."
    if [[ ${#PROVISIONED_AGENTS[@]} -eq 0 ]]; then
      echo "Run './specify-run init --ai <agent>' to provision project files."
    else
      echo "Please commit these changes, then re-run ./specify-run:"
      echo "  git add -A && git commit -m \"chore: upgrade SpecKit to $SPECKIT_REF\""
    fi
    exit "$EX_TEMPFAIL"
  fi
  info "Installing SpecKit ($SPECKIT_REF)"
  "$PIP" install --upgrade \
    "git+$SPECKIT_GIT@$SPECKIT_REF"
  touch "$STAMP"
fi

[[ -x "$SPECIFY" ]] || die "SpecKit entrypoint missing after install"

# ---------------------------------------------------------------------------
# Guardrails
# ---------------------------------------------------------------------------

# Disallow accidental global invocation fallback
if [[ "$(command -v specify 2>/dev/null || true)" != "$SPECIFY" ]]; then
  :
  # intentionally silent; wrapper always wins
fi

# ---------------------------------------------------------------------------
# Verify security hardenings (existing environment only)
# ---------------------------------------------------------------------------

if [[ "$FRESH_PROVISIONING" == "false" ]] && ! check_gitignore_hardenings; then
  show_missing_hardenings
  block_if_target_dirty
  prompt_user "gitignore" "About to restore missing .gitignore patterns"
  apply_gitignore_hardenings
  stop_after_gitignore_fix
fi

# ---------------------------------------------------------------------------
# Exec
# ---------------------------------------------------------------------------

exec "$SPECIFY" "$@"

